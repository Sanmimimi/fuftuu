---
title: "数据结构与算法实习第二阶段"
author: 孙百乐
date: 2022-07-02T15:38:13+08:00
draft: false
categories: 
- 刷题
- 笔记
---



## 7-2 分而治之

**知识点**：图论

**思路**：

* 记录邻接矩阵，输入时记录每个节点的度数。被摧毁的城市的度置为0，和它相邻的点度也-1。最后检查是否有度大于0的点，有就说明有城市相连通，输出NO，否则输出YES；
* 记录所有的边(u, v)，和被攻陷城池lost[i]。遍历边(u, v)，如果存在u或v没有被攻陷（即不在lost里面），说明有城市连通，输出NO，否则YES；

因为这题最多有10005个点，使用邻接矩阵会超内存，所以采用第二种思路；

**细节**：

* 记录边可以使用两个数组`u[10005]`和`v[10005]`，第`i`条边的两个节点是`u[i]`和`v[i]`
* 判断边中是否包含没被攻陷的城池`if( !lost[u[i]] && !lost[v[i]] )`

**代码**：

```c++
#include <iostream>;
using namespace std;

class Citys {
public:
    int N, M;
    int u[10005]={0};
    int v[10005]={0}; // 第 i 条边为 (u[i], v[i])
    void insertPath(); // 输入路径
    bool isValid(); // 输入一个方案，判断是否有效
    Citys();
};

Citys::Citys() {
    cin >> N >> M;
}

void Citys::insertPath() {
    for(int i=0; i<M; i++){
        cin >> u[i] >> v[i];
    }
}

bool Citys::isValid() {
    // 输入攻破的城池
    int Np; cin >> Np;
    int lost[10005] = {0};
    for( int i=0; i<Np; i++ ){
        int city; cin >> city;
        lost[city] = 1;
    }
    // 判断
    for( int i=0; i<M; i++ ){
        if( !lost[u[i]] && !lost[v[i]] ){ // 如果都不是被攻陷的城池
            return false;
        }
    }
    return true;

}
int main() {
    // 输入数据
    Citys citys = Citys();
    citys.insertPath();
    int K; cin >> K;
    for( int i=0; i<K; i++ ){
        if( citys.isValid() ) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
  
    return 0;
}

```

