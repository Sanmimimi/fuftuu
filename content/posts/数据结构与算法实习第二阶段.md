---
title: "数据结构与算法实习第二阶段"
author: 孙百乐
date: 2022-07-02T15:38:13+08:00
draft: false
categories: 
- 刷题
- 笔记
---



## 7-2 分而治之

**知识点**：图论

**思路**：

* 思路一：记录邻接矩阵，输入时记录每个节点的度数。被摧毁的城市的度置为0，和它相邻的点度也-1。最后检查是否有度大于0的点，有就说明有城市相连通，输出NO，否则输出YES；
* 思路二：记录所有的边(u, v)，和被攻陷城池lost[i]。遍历边(u, v)，如果存在u或v没有被攻陷（即不在lost里面），说明有城市连通，输出NO，否则YES；

因为这题最多有10005个点，使用邻接矩阵会超内存，所以采用第二种思路；

**细节**：

* 记录边可以使用两个数组`u[10005]`和`v[10005]`，第`i`条边的两个节点是`u[i]`和`v[i]`
* 判断边中是否包含没被攻陷的城池`if( !lost[u[i]] && !lost[v[i]] )`

**代码**：

```c++
#include <iostream>;
using namespace std;

class Citys {
public:
    int N, M;
    int u[10005]={0};
    int v[10005]={0}; // 第 i 条边为 (u[i], v[i])
    void insertPath(); // 输入路径
    bool isValid(); // 输入一个方案，判断是否有效
    Citys();
};

Citys::Citys() {
    cin >> N >> M;
}

void Citys::insertPath() {
    for(int i=0; i<M; i++){
        cin >> u[i] >> v[i];
    }
}

bool Citys::isValid() {
    // 输入攻破的城池
    int Np; cin >> Np;
    int lost[10005] = {0};
    for( int i=0; i<Np; i++ ){
        int city; cin >> city;
        lost[city] = 1;
    }
    // 判断
    for( int i=0; i<M; i++ ){
        if( !lost[u[i]] && !lost[v[i]] ){ // 如果都不是被攻陷的城池
            return false;
        }
    }
    return true;

}
int main() {
    // 输入数据
    Citys citys = Citys();
    citys.insertPath();
    int K; cin >> K;
    for( int i=0; i<K; i++ ){
        if( citys.isValid() ) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
  
    return 0;
}

```

## 7-3 那就别担心了

**知识点**：dfs、时间复杂度

**思路**：抽象一下：给定一个有向无环图（DAG），并且给出起点A和终点B，问从A出发的所有路径是否都能到达B，并且求出从A出发到达B的不同路径有多少条。第一个问题非常好解，只要从A开始DFS，如果搜到某个出度为0的点，并且这个点不是题面给出的B点，就说明并不是所有从A出发的路径都能到达B。对于第二个问题，虽然这道题数据比较小，最多只有500个点，但是这题的时间限制是400ms，对于求解不同路径的问题，如果暴力搜索的话是一定会超时的。

考察输入样例1:

```
7 8
7 6
8 5
6 5
5 2
5 3
2 1
3 1
7 1
```



![7-3 那就别担心了题解DAG](https://myblog-1257298572.cos.ap-shanghai.myqcloud.com/img/7-3%20%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86%E9%A2%98%E8%A7%A3DAG.jpg)

很明显，从7到1有如下路径：

```
7 -> 6 -> 5 —> 2 -> 1
7 -> 6 -> 5 -> 3 -> 1
7 -> 8 -> 5 -> 2 -> 1
7 -> 8 -> 5 -> 3 -> 1
```

发现，从5到1有两条路径。在搜索时，经过7，6，5，会把这两条路径都搜索一遍；经过7，8，5，又会把这两条路径搜索一遍。这样就造成了时间的浪费。我们考虑，如果在经过6号节点到达5号节点，再到达终点1号节点的所有路径全部搜索完时，5号节点能够储存下“经过该节点有2条路径到达目标节点”这个信息，这样在从8号节点搜索到5号时，就不需要再重复地将接下来的路径全部搜索一遍了，直接从5号节点读到“接下来有2条不同的路径”这个信息。正好，DFS的“走到底再返回”的性质可以做到从尾到头，也就是从终点到起点记录信息，因此我们可以在DFS的过程中进行记忆化操作。

我们定义`step[i]`为“从`i`号节点到达目标节点的路径条数“，求解的目标是`step[A]`，定义`step[B] = 1`，并且标记𝐵B节点已经被访问过。在DFS的过程中，如果将要搜索的节点没有被访问过，就搜索，并记录下路径条数，当前节点直接加上待搜索（其实这时候已经搜索完了）的节点的路径条数。以上图为例，DFS的过程如下：

1. 初始化`step[]`数组为0，初始化`vis[]`数组为**false**，赋值`step[1]=1`, `vis[1]=true`;
2. 从起点7开始DFS，赋值`vis[7]=true`。接下来想搜索6，`vis[6]==false`，进入；
3. 从6节点开始DFS，赋值`vis[6]=true`。接下来想搜索5，`vis[5]==false`，进入；
4. 从5节点开始DFS，赋值`vis[5]=true`。接下来想搜索2，`vis[2]==false`，进入；
5. 从2节点开始DFS，赋值`vis[2]=true`。接下来想搜索1，`vis[1]==true`，不进入；累加路径条数`step[2]=step[2]+step[1]`，这时`step[2]=1`。2节点没有其他的路径，返回，`step[5]=step[5]+step[2]`,此时`step[5]=1`
6. 接下来想搜索3，赋值`vis[1]==true`，不进入；累加路径条数`step[3]=step[3]+step[1]`，这时`step[3]=1`。3节点没有其他的路径，返回,`step[5]=step[5]+step[3]`,此时`step[5]=2`
7. 5节点没有其他的路径，返回，`step[6]=step[6]+step[5]`，此时`step[6]=2`.
8. 6没有其它节点了，返回7，`step[7]=step[7]+step[6]`，此时`step[7]=2`。继续搜索8。
9. 从8开始DFS，赋值`vis[8]=true`，接下来又想搜索5，`vis[5]=true`，不进入，`step[8]=step[8]+step[5]`，此时`step[8]=2`；
10. 没有其它路径了，返回7，`step[7]=step[7]+step[8]`，此时`step[7]=4`。没有其它节点了，递归结束。

**细节**：

* 路径使用邻接矩阵存储（邻接表更节省空间，但因为不能使用`vector`，所以邻接表实现起来会麻烦一点）
* 判断能否“逻辑自洽”：出度为0且该节点不是终点，令全局变量`isLogic`

dfs的过程用代码实现：

```c++
void Propositions::dfs(int node) {
    vis[node] = true;
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}
```

所有代码：

```c++
#include <iostream>
using namespace std;

class Propositions {
public:
    int N, M;
    int start, end; // 起点和终点
    int isLogic = true; // 是否逻辑自洽
    int path[505][505]; // 邻接矩阵，在构建函数中初始化为0；
    long long step[505] = {0}; // step[i] : 第 i 个点到终点的路径的个数
    bool vis[505] = {0}; // 是否访问过

    Propositions();
    void insertPath(); // 输入路径
    int getOutdegree(int node); // 计算一个节点的出度
    void dfs(int node); // 深度优先搜索
    void detect(); // 推理入口
};

Propositions::Propositions() {
    for( int i=0; i<N+1; i++ ){
        for( int j=0; j<N+1; j++ ){
            path[i][j] = 0;
        }
    }
}

void Propositions::insertPath() {
    cin >> N >> M;
    for( int i=0; i<M; i++ ){
        int from, to; cin >> from >> to;
        path[from][to] = 1;
    }
}

int Propositions::getOutdegree(int node) {
    int sum = 0;
    for( int i=0; i<N+1; i++ ){
        sum += path[node][i];
    }
    return sum;
}

void Propositions::dfs(int node) {
    vis[node] = true;
    if ( getOutdegree(node) == 0 && node != end ){
        isLogic = false;
    }
    for( int i=0; i<N+1; i++ ){
        if( path[node][i] ){
            if( !vis[i] ) dfs(i);
            step[node] = step[node] + step[i];
        }
    }
}

void Propositions::detect() {
    cin >> start >> end;
    step[end] = 1; // 重要初始化
    vis[end] = true; // 重要初始化
    dfs(start);
    cout << step[start] << " " ;
    if( isLogic ) cout << "Yes";
    else cout << "No";
}

int main() {
    Propositions p;
    p.insertPath();
    p.detect();
    return 0;
}

```

